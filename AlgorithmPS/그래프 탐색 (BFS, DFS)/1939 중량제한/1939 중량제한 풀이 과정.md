ğŸ“Œ â†’ https://www.acmicpc.net/problem/1939 <br/><br/>

**ì£¼ì˜í•  ì **

1. ë²”ìœ„ê°€ ë„“ê³ , ì‹œê°„ ì œí•œì´Â **1ì´ˆ**Â ì´ë©° ìµœëŒ“ê°’ì„ êµ¬í•˜ë¼ëŠ” ëœ»ì€ í•œ ê°’ì´ ì•„ë‹ŒÂ **ì—¬ëŸ¬ ê°’ì´ ì •ë‹µìœ¼ë¡œ ë‚˜ì˜¬ ìˆ˜ ìˆë‹¤**ëŠ” ëœ» â†’ ì—¬ê¸°ì„œ ì´ì§„ íƒìƒ‰ì„ ìƒê°í•´ì•¼ í•œë‹¤. <br/><br/>

**í•µì‹¬ ë¡œì§**

1. **left ë¥¼ 0**ë¡œ,Â **right ë¥¼ ë‹¤ë¦¬ë“¤ ì¤‘ ìµœëŒ€ ì¤‘ëŸ‰**ìœ¼ë¡œ ì„¤ì •.
2. ì´ì§„íƒìƒ‰ whileë¬¸ ë°˜ë³µ
3. **BFS ë°©ì‹**ì„ í†µí•´ pollí•œ ê³µì¥ì— ì—°ê²°ëœ ì ‘ì ì˜ ê³µì¥ë“¤ì„ Queueì— ë‹´ì•„ê°€ë©°, Bê³µì¥ì— ë„ì°©í•  ë•Œ ê¹Œì§€ ë°˜ë³µ
    
    ** ë¬¼ë¡ , ì‹œì‘ ì§€ì ì€ Aê³µì¥ì´ë‹¤.
    
4. 4ë²ˆ ë°©ì‹ì„ ì§„í–‰í•˜ë©´ì„œ ê°„ì„ (ë‹¤ë¦¬)ë“¤ì˜ ë¬´ê²Œ ì¤‘ëŸ‰ê³¼ mid(ì„ íƒí•œ ì´ë™ ê°€ëŠ¥ ì¤‘ëŸ‰) ê°’ì„ ë¹„êµí•œë‹¤.
    
    ->Â **mid ê°’ë³´ë‹¤ í° ê²½ìš°**Â : í•´ë‹¹ ê³µì¥ì„ ê¸°ì¤€ìœ¼ë¡œ 4ë²ˆ ì´ì–´ì„œ ì§„í–‰. (ë‹¤ìŒ ê²½ë¡œë¥¼ íƒìƒ‰)
    
    ->Â **mid ê°’ë³´ë‹¤ ì‘ì€ ê²½ìš°**Â : False. ë‹¤ë¦¬ë¥¼ ê±´ë„ˆì§€ ëª»í•˜ë¯€ë¡œ í•´ë‹¹ ê²½ë¡œë¡œ íƒìƒ‰ ì¢…ë£Œ. ê·¸ëƒ¥ ë‹¤ìŒ ì›ì†Œë¥¼ íì—ì„œ pollí•œë‹¤.
    
5. ëª©ì ì§€ ê³µì¥(Bê³µì¥)ì— í•˜ë‚˜ë¼ë„ ë„ì°©í•˜ê±°ë‚˜ í•˜ë‚˜ë¼ë„ ë„ì°©í•˜ì§€ ëª»í•˜ë©´ BFSë¥¼ ì¢…ë£Œí•œë‹¤.
    
    ê·¸ í›„,Â **í•˜ë‚˜ë¼ë„ ë„ì°©í•œ ê²½ìš°**Â **->**Â ë³„ë„ë¡œ mid ê°’ ì €ì¥í•´ì„œ ìµœëŒ“ê°’ ì°¾ê¸°. ë‹¤ìŒì— ìœ— ë°°ì—´ íƒìƒ‰(left = mid + 1)
    
    **í•˜ë‚˜ë¼ë„ ë„ì°©í•˜ì§€ ëª»í•œ ê²½ìš°**Â **->**ë‹¤ìŒì— ì•„ë˜ ë°°ì—´ íƒìƒ‰(right = mid - 1)
    
6. ê·¸ë˜ì„œ Bê³µì¥ì— ë„ì°©í•œ ê²ƒë“¤ ì¤‘Â **ìµœëŒ“ê°’ì„ ì¶œë ¥** <br/><br/>

- **ê°„ì„ ì´ 10ë§Œê°œê°€ ë„˜ëŠ”ë° ê·¸ ì¤‘ ë„ì°©ì§€ì ì´ ìˆë‹¤ë©´?**

> 10ë§Œê°œë¥¼ Queueì— ë„£ì€ í›„, í•˜ë‚˜ì”© ê¹Œë³´ë©´ì„œ ì°¾ì•„ì•¼ í•œë‹¤.

> ê·¸ë ‡ê²Œ ë˜ë©´ ì†Œìš” ì‹œê°„ë„ í›¨ì”¬ ì¦ê°€í•  ê²ƒì´ë‹¤.

ê·¸ë ‡ê¸° ë•Œë¬¸ì—Â **ì•„ë˜ì— ì ì€ ê²ƒ**ì²˜ëŸ¼Â **ì•Œê³ ë¦¬ì¦˜ì„ ê°œì„ ì‹œì¼œ ì‹œê°„ì„ í›¨ì”¬ ì¤„ì˜€ë‹¤.**Â 

-Â  pollí•œ ì›ì†Œì˜ ì—°ê²° ë‹¤ë¦¬ë“¤ ì¤‘Â **midê°’ë³´ë‹¤ í¬ë©´**Â Queueì— ë„£ê¸°

-Â  poll í•œ ì›ì†Œì™€ ì¸ì ‘í•œ ì ‘ì (ê³µì¥ë“¤)ë“¤ì„ ë„£ê¸° ì „ì—Â **ë°©ë¬¸ ì—¬ë¶€ë¥¼ ì²´í¬**í•˜ê¸°

-Â  poll í•œ ì›ì†Œì™€ ì¸ì ‘í•œ ì ‘ì (ê³µì¥ë“¤)ë“¤ì„ ë„£ê¸° ì „ì—Â **ëª©ì ì§€ ê³µì¥(Bê³µì¥) ì—¬ë¶€ë¥¼ ì²´í¬**í•˜ê¸° <br/><br/>

cf) https://maivve.tistory.com/144

```
3 3
1 2 2
3 1 3
2 3 2
1 3
```

### ìµœì¢… ê²°ê³¼ (576 ms â†’ BFS + ì´ì§„ íƒìƒ‰)

```java
import java.io.*;
import java.util.*;

public class Main {

    static int n, m, maxWeight, left, right;
    static boolean[] visited;
    static List<List<Node>> islandBridge;
    static int[] dx = {-1,1,0,0};
    static int[] dy = {0,0,-1,1};

    static class Node {

        int v, w;

        Node(int v, int w) {
            this.v = v;
            this.w = w;
        }
    }

    public static void main(String[] args) throws IOException {

        // BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedReader br = new BufferedReader(new FileReader("input.txt"));
        StringTokenizer st = new StringTokenizer(br.readLine());

        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        maxWeight = 0;
        islandBridge = new ArrayList<>();

        for (int i = 0; i <= n; i++) { // ì •ì ì˜ ì‹œì‘ì´ 1ë¶€í„° ì´ê¸° ë•Œë¬¸ì— 0 ì¸ë±ìŠ¤ëŠ” ì±„ìš°ì§€ ì•Šê³  1 ~ n
            islandBridge.add(new ArrayList<Node>());
        }
        

        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());

            int v1 = Integer.parseInt(st.nextToken());
            int v2 = Integer.parseInt(st.nextToken());
            int w = Integer.parseInt(st.nextToken());

            islandBridge.get(v1).add(new Node(v2, w));
            islandBridge.get(v2).add(new Node(v1, w));

            maxWeight = Math.max(maxWeight, w);
        }

        right = maxWeight;

        st = new StringTokenizer(br.readLine());

        int start = Integer.parseInt(st.nextToken());
        int end = Integer.parseInt(st.nextToken());

        while (left <= right) {

            int mid = (left + right) / 2;
            visited = new boolean[n+1];

            if (bfs(start, end, mid)) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        System.out.println(right);

        br.close();
    }

    private static boolean bfs(int start, int end, int mid) {

        Queue<Integer> q = new LinkedList<>();
        q.add(start);
        visited[start] = true;

        while (!q.isEmpty()) {
            int startPoint = q.poll();

            if (startPoint == end) {
                return true;
            }

            for (Node now : islandBridge.get(startPoint)) {
                if (!visited[now.v] && mid <= now.w) { // midëŠ” ìµœëŒ€ ì¤‘ëŸ‰ ê¸°ì¤€
                    visited[now.v] = true;
                    q.add(now.v);
                }
            }
        }

        return false;
    }
}
```

### DFS (620 ms)

```java
import java.io.*;
import java.util.*;

public class Main {

    static int n, m, maxWeight, left, right, ans;
    static boolean[] visited;
    static List<List<Node>> islandBridge;
    static int[] dx = {-1,1,0,0};
    static int[] dy = {0,0,-1,1};

    static class Node {

        int v, w;

        Node(int v, int w) {
            this.v = v;
            this.w = w;
        }
    }

    public static void main(String[] args) throws IOException {

        // BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedReader br = new BufferedReader(new FileReader("input.txt"));
        StringTokenizer st = new StringTokenizer(br.readLine());

        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        maxWeight = 0;
        islandBridge = new ArrayList<>();

        for (int i = 0; i <= n; i++) { // ì •ì ì˜ ì‹œì‘ì´ 1ë¶€í„° ì´ê¸° ë•Œë¬¸ì— 0 ì¸ë±ìŠ¤ëŠ” ì±„ìš°ì§€ ì•Šê³  1 ~ n
            islandBridge.add(new ArrayList<Node>());
        }
        

        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());

            int v1 = Integer.parseInt(st.nextToken());
            int v2 = Integer.parseInt(st.nextToken());
            int w = Integer.parseInt(st.nextToken());

            islandBridge.get(v1).add(new Node(v2, w));
            islandBridge.get(v2).add(new Node(v1, w));

            maxWeight = Math.max(maxWeight, w);
        }

        right = maxWeight;

        st = new StringTokenizer(br.readLine());

        int start = Integer.parseInt(st.nextToken());
        int end = Integer.parseInt(st.nextToken());

        while (left <= right) {

            int mid = (left + right) / 2;
            visited = new boolean[n+1];
            ans = -1;

            dfs(start, end, mid);

            if (ans != -1) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        System.out.println(right);

        br.close();
    }

    private static void dfs(int start, int end, int mid) {

        if (start == end) {
            ans = start;
            return;
        }

        visited[start] = true;

        for (Node now : islandBridge.get(start)) {
            if (!visited[now.v] && mid <= now.w) {
                dfs(now.v, end, mid);
            }
        }
    }
}
```
