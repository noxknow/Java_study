ğŸ“Œ â†’ https://www.acmicpc.net/problem/2206 <br/><br/>

**í•µì‹¬ ë¡œì§**

1. ì²˜ìŒ ìƒê°í–ˆë˜ ë¡œì§ì€ ë²½ì´ì˜€ë˜ ë¶€ë¶„ì„ ë”°ë¡œ ê°–ê³ ìˆëŠ” ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ì–´ í•˜ë‚˜ì”© ë²½ì„ ë¶€ìˆœë‹¤ê³  ê°€ì •í•˜ê³  ì™„ì „ íƒìƒ‰ìœ¼ë¡œ í’€ë ¤ê³ í–ˆë‹¤. í•˜ì§€ë§Œ ë²½ì„ ë¶€ìˆ˜ì§€ ì•Šê³  ì´ë™í•˜ëŠ” ê²½ìš°ë¥¼ ê³ ë ¤í•˜ì§€ ëª»í•˜ê³  ì‹œê°„ ì´ˆê³¼ê°€ ë°œìƒí–ˆê¸° ë•Œë¬¸ì— ë‹¤ë¥¸ë¶„ë“¤ì˜ ì½”ë“œë¥¼ ë³´ê³  ë°©ì‹ì„ ë°”ê¾¸ê²Œ ë˜ì—ˆë‹¤. <br/><br/>

- ë‹¤ìŒ ì¹¸ì— ë²½ì´ ìˆì„ ê²½ìš°
    1. ë²½ì„Â **ë¶€ìˆœì ì´ ì—†ëŠ”ì§€**Â ì²´í¬
    2. í•´ë‹¹ ë²½ì„ ì´ì „ì—Â **ë¶€ìˆ˜ê³  ë°©ë¬¸**í•œ ì ì´ ì—†ëŠ”ì§€
- ë‹¤ìŒ ì¹¸ì— ë²½ì´ ì—†ì„ ê²½ìš°
    1. **ë²½ì„ ë¶€ìˆœ ì—¬ë¶€**ì— ë”°ë¼ ë‹¤ìŒ ì¹¸ì„Â ë°©ë¬¸í–ˆëŠ”ì§€ ì²´í¬ 

```java
// 3ì°¨ì› ë°°ì—´ : [ë²½ì„ ë¶€ì‰ˆëŠ”ì§€ 0,1]
boolean[][][] visit = new boolean[2][N][M];
```

```
6 4
0100
1110
1000
0000
0111
0000
```

### ìµœì¢… ê²°ê³¼ (1324 ms)

```java
import java.io.*;
import java.util.*;

public class Main {

    static int n, m;
    static Queue<Node> q;
    static int[][] basicMap;
    static boolean visited[][][];
    static int[] dx = { -1, 1, 0, 0 };
    static int[] dy = { 0, 0, -1, 1 };

    static class Node {

        int x, y, dist;
        boolean broke;

        Node (int x, int y, int dist, boolean broke) {
            this.x = x;
            this.y = y;
            this.dist = dist; 
            this.broke = broke; //ë²½ ë¶€ìˆœ ì—¬ë¶€
        }
    }

    public static void main(String[] args) throws IOException {

        // BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedReader br = new BufferedReader(new FileReader("input.txt"));
        StringTokenizer st = new StringTokenizer(br.readLine());

        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        basicMap = new int[n+1][m+1];
        visited = new boolean[2][n+1][m+1];

        for (int i=1; i<=n; i++) {
            String[] line = br.readLine().split("");
            for (int j=1; j<=m; j++) {
                basicMap[i][j] = Integer.parseInt(line[j-1]);
            }
        }

        bfs();

        br.close();
    }

    private static void bfs() {

        q = new LinkedList<>();
        q.add(new Node(1, 1, 1, false)); // ì‹œì‘ì  íì— ë„£ê¸°
        visited[0][1][1] = true; 

        while(!q.isEmpty()) {
            Node now = q.poll();

            if (now.x == n && now.y == m) {
                System.out.println(now.dist);
                return;
            }

            for (int i=0; i<4; i++) {
                int nx = now.x + dx[i];
                int ny = now.y + dy[i];
                int nDist = now.dist+1;

                if (nx <= 0 || nx > n || ny <= 0 || ny > m) continue; // ë§µ ë²”ìœ„ ë²—ì–´ë‚˜ëŠ” ê²½ìš°

                // (1) ë²½ì´ ì•„ë‹ˆë©´
                // a. ë²½ì„ í•œë²ˆë„ ì•ˆ ë¶€ìˆ˜ê³  ì§„í–‰í•´ì˜¨ ê²½ìš°
                // b. ë²½ì„ í•œë²ˆ ë¶€ìˆ˜ê³  ì§„í–‰í•´ì˜¨ ê²½ìš°
                if (basicMap[nx][ny] == 0) { 
                    if (!now.broke) { 
                        if (visited[0][nx][ny]) continue; // ë°©ë¬¸í•œ ê³³ì´ë©´ íŒ¨ìŠ¤

                        visited[0][nx][ny] = true; // ë²½ ì•ˆë¶€ìˆœ ë°©ë¬¸ì²˜ë¦¬
                        q.add(new Node(nx, ny, nDist, false));
                    } else { 
                        if (visited[1][nx][ny]) continue; // ë°©ë¬¸í•œ ê³³ì´ë©´ íŒ¨ìŠ¤

                        visited[1][nx][ny] = true; // ë²½ ë¶€ìˆœ ë°©ë¬¸ì²˜ë¦¬
                        q.add(new Node(nx, ny, nDist, true));
                    }
                } else { 
                // (2) ë²½ì´ë©´
                // a. ì§€ê¸ˆê¹Œì§€ ë²½ì„ í•œë²ˆë„ ì•ˆ ë¶€ìˆ˜ê³  ì§„í–‰í•´ì˜¨ ê²½ìš°
                // b. ë²½ì„ í•œë²ˆ ë¶€ìˆ˜ê³  ì§„í–‰í•´ì˜¨ ê²½ìš°
                    if (!now.broke) { 
                        visited[1][nx][ny] = true; // ë²½ ë¶€ìˆœ ë°©ë¬¸ì²˜ë¦¬

                        q.add(new Node(nx, ny, nDist, true)); // ë²½ ë¶€ìˆœê±° ê¸°ë¡
                    }
                }
            }
        }

        System.out.println(-1);
    }
}
```

### ì‹œê°„ ì´ˆê³¼

```java
import java.io.*;
import java.util.*;

public class Main {

    static int n, m;
    static int[][] basicMap;
    static List<int[]> wallMap;
    static Queue<int[]> q;
    static int[] dx = { -1, 1, 0, 0 };
    static int[] dy = { 0, 0, -1, 1 };
    public static void main(String[] args) throws IOException {

        // BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedReader br = new BufferedReader(new FileReader("input.txt"));
        StringTokenizer st = new StringTokenizer(br.readLine());

        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        basicMap = new int[n+1][m+1];
        wallMap = new ArrayList<>();

        for (int i=0; i<n; i++) {
            String[] line = br.readLine().split("");
            for (int j=0; j<m; j++) {
                basicMap[i][j] = Integer.parseInt(line[j]);

                if (basicMap[i][j] == 1) {
                    wallMap.add(new int[] {i, j});
                }
            }
        }

        List<Integer> result = bfs();

        if (result.isEmpty()) {
            System.out.println(-1);
        } else {
            System.out.println(Collections.min(result));
        }

        br.close();
    }

    private static List<Integer> bfs() {

        List<Integer> result = new ArrayList<>();
        int[][] newMap;

        for (int[] wall : wallMap) {
            int wx = wall[0];
            int wy = wall[1];
            newMap = copyMap(basicMap);
            newMap[wx][wy] = 0;
            newMap[0][0] = 1;

            q = new LinkedList<>();
            q.add(new int[] {0, 0});

            while (!q.isEmpty()) {
                int[] tmp = q.poll();
                int x = tmp[0];
                int y = tmp[1];

                for (int i=0; i<4; i++) {
                    int nx = x + dx[i];
                    int ny = y + dy[i];

                    if (range(nx, ny) && newMap[nx][ny] == 0) {
                        newMap[nx][ny] = newMap[x][y] + 1;
                        q.add(new int[] {nx, ny});
                    }
                }
            }

            if (newMap[n-1][m-1] != 0) {
                result.add(newMap[n-1][m-1]);
            }
        }

        return result;
    }

    private static boolean range(int x, int y) {
        return x>=0 && y>=0 && x<n && y<m;
    }

    private static int[][] copyMap(int[][] original) {
        int[][] copy = new int[original.length][];
        for (int i = 0; i < original.length; i++) {
            copy[i] = Arrays.copyOf(original[i], original[i].length);
        }

        return copy;
    }
}
```
