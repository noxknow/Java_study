ğŸ“Œ â†’ https://www.acmicpc.net/problem/17135 <br/><br/>

**ì£¼ì˜í•  ì **

1. ê°™ì€ ì ì´ ì—¬ëŸ¬ ê¶ìˆ˜ì—ê²Œ ê³µê²© ë‹¹í•  ìˆ˜ ìˆë‹¤. â†’ í° ë¬¸ì œê°€ ì•„ë‹ˆë¼ê³  ìƒê°í–ˆì§€ë§Œ ì²«ë²ˆì§¸ ê¶ìˆ˜ê°€ ì¡ì€ ì ì„ ë‘ë²ˆì§¸ ê¶ìˆ˜ê°€ ì œì™¸í•˜ë©´ ì•ˆëœë‹¤ <br/><br/>
2. ì–•ì€ ë³µì‚¬ì™€ ê¹Šì€ ë³µì‚¬ ì£¼ì˜ <br/><br/>

**í•µì‹¬ ë¡œì§**

1. ê¶ìˆ˜ë¥¼ ë°°ì¹˜í•´ì¤€ë‹¤. â†’ ì¡°í•©ì„ í†µí•´ ëª¨ë“  ë°°ì¹˜ë¥¼ íƒìƒ‰í•˜ëŠ” ê²ƒ ë§ê³  ë‹¤ë¥¸ ë°©ë²•ì´ ì—†ì„ì§€ ìƒê°í–ˆì§€ë§Œ ëª¨ë“  ë°°ì¹˜ íƒìƒ‰ ì´ì™¸ì˜ ë°©ì‹ì´ ìƒê°ë‚˜ì§€ ì•Šì•˜ë‹¤. <br/><br/>
2. ìš°ì„ ìˆœìœ„ íë¥¼ í™œìš©í•˜ì—¬ ê°€ì¥ ê°€ê¹ê³ , ì—¬ëŸ¬ ì ì´ ê°€ê¹ë‹¤ë©´ ê°€ì¥ ì™¼ìª½ ì ì´ ì œê±°ë˜ë„ë¡ êµ¬í˜„ <br/><br/>
3. ì ë“¤ ë¦¬ìŠ¤íŠ¸ì™€ ì œê±°ë  ë¦¬ìŠ¤íŠ¸ë¥¼ ë¹„êµí•˜ì—¬ ì œê±°í•œ í›„ ì ë“¤ ë¦¬ìŠ¤íŠ¸ í–‰ í•œì¹¸ì”© ëŠ˜ë¦¬ê³  ì„±ì— ë‹¿ì€ ì ë“¤ì€ ì œê±°í•´ì£¼ëŠ” ë°©ì‹ìœ¼ë¡œ ë°˜ë³µì„ ì§„í–‰í•œë‹¤. <br/><br/>

```
6 5 1
1 0 1 0 1
0 1 0 1 0
1 1 0 0 0
0 0 0 1 1
1 1 0 1 1
0 0 1 0 0
```

### ìµœì¢… ê²°ê³¼ (452 ms)

```java
import java.io.*;
import java.util.*;

public class Main {

    static int n, m, dist, res;
    static int[] archer;
    static int[][] castleMap;
    static List<int[]> monsterGroup;
    static int[] dx = {-1,1,0,0};
    static int[] dy = {0,0,-1,1};

    static class Node implements Comparable<Node> {

        int x, y, d;

        Node(int x, int y, int d) {
            this.x = x;
            this.y = y;
            this.d = d;
        }

        @Override
        public int compareTo(Node o) {
            if (this.d == o.d) { // ê±°ë¦¬ê°€ ê°™ë‹¤ë©´
                return this.y - o.y; // ì—´ì´ ë” ì‘ì€ ê°’(ë” ì™¼ìª½)
            } else
                return this.d - o.d; // ì˜¤ë¦„ì°¨ìˆœ
        }
    }

    public static void main(String[] args) throws IOException {

        // BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedReader br = new BufferedReader(new FileReader("input.txt"));
        StringTokenizer st = new StringTokenizer(br.readLine());

        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        dist = Integer.parseInt(st.nextToken());

        archer = new int[3];
        monsterGroup = new ArrayList<>();
        castleMap = new int[n][m];

        for (int i = 0; i < n; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 0; j < m; j++) {
                castleMap[i][j] = Integer.parseInt(st.nextToken());

                if (castleMap[i][j] == 1) {
                    monsterGroup.add(new int[]{i, j});
                }
            }
        }

        locateArcher(0, 0);

        System.out.println(res);

        br.close();
    }

    private static void locateArcher(int index, int start) {
        if (index == 3) {
            List<int[]> newMonsterGroup = copy(monsterGroup);
            action(newMonsterGroup);
            return;
        }

        for (int i = start; i < m; i++) {
            archer[index] = i;
            locateArcher(index + 1, i + 1);
        }
    }

    private static List<int[]> copy(List<int[]> monsterGroup) {
        List<int[]> tmp = new ArrayList<>();

        for (int[] cur : monsterGroup) {
            tmp.add(new int[]{cur[0], cur[1]});
        }

        return tmp;
    }

    private static void action(List<int[]> newMonsterGroup) {
        int cnt = 0;

        while (!newMonsterGroup.isEmpty()) {
            List<int[]> targets = new ArrayList<>();

            for (int i = 0; i < 3; i++) {
                PriorityQueue<Node> pq = new PriorityQueue<>();

                for (int j = 0; j < newMonsterGroup.size(); j++) {
                    int[] cur = newMonsterGroup.get(j);
                    int diffDist = Math.abs(cur[0] - n) + Math.abs(cur[1] - archer[i]);
                    if (diffDist <= dist) {
                        pq.add(new Node(cur[0], cur[1], diffDist));
                    }
                }

                if (!pq.isEmpty()) {
                    Node target = pq.poll();
                    boolean flag = false;
                    for (int j = 0; j < targets.size(); j++) {
                        int[] cur2 = targets.get(j);
                        if (cur2[0] == target.x && cur2[1] == target.y) {
                            flag = true;
                            break;
                        }
                    }

                    if (!flag) {
                        targets.add(new int[]{target.x, target.y});
                    }
                }
            }

            for (int i = 0; i < targets.size(); i++) {
                for (int j = newMonsterGroup.size() - 1; j >= 0; j--) {
                    if (targets.get(i)[0] == newMonsterGroup.get(j)[0] && targets.get(i)[1] == newMonsterGroup.get(j)[1]) {
                        newMonsterGroup.remove(j);
                        cnt++;
                        break;
                    }
                }
            }

            for (int i = newMonsterGroup.size() - 1; i >= 0; i--) {
                newMonsterGroup.get(i)[0] += 1;
                if (newMonsterGroup.get(i)[0] == n)
                    newMonsterGroup.remove(i);
            }
        }

        res = Math.max(res, cnt);
    }
}
```
